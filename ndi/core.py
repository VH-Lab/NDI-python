from __future__ import annotations
import ndi.types as T
from .document import Document
from .database.ndi_database import NDI_Database
from .query import Query as Q
from pathlib import Path
import re
from abc import ABC, abstractmethod
import flatbuffers
from uuid import uuid4
import os

class NDI_Object:
    """
    Abstract class for NDI flatbuffer interfaces.
    Child classes of :class:`NDI_Object` are wrappers for the classes generated by `ndi_schema <>`_ and serve as simplified interfaces for quickly converting between ndi objects and flatbuffer bytearrays.
    """

    DOCUMENT_TYPE = ''

    def __init__(self,  id_: T.Optional[T.NdiId]):
        """NDI_Object constructor: initializes id property.
        op8
        :param id_: A unique id.
        :type id_: str, optional
        """
        self.document = Document(id_=id_)
    
    @property
    def ctx(self):
        return self.document.ctx

    def set_ctx(self, new_ctx):
        self.document.set_ctx(new_ctx)
    def with_ctx(self, new_ctx):
        self.document.set_ctx(new_ctx)
        return self
    
    @property
    def binary(self):
        return self.document.binary

    @property
    def id(self):
        return self.document.id

    @property
    def metadata(self):
        return self.document.metadata
    @metadata.setter
    def metadata(self, new_metadata):
        self.document.metadata = new_metadata

    @property
    def dependencies(self):
        return self.document.dependencies
    @dependencies.setter
    def dependencies(self, dependencies):
        self.document.dependencies = dependencies

    @property
    def depends_on(self):
        return self.document.depends_on
    @depends_on.setter
    def depends_on(self, depends_on):
        self.document.depends_on = depends_on
    
    @property
    def current(self):
        return self.refresh()

    def refresh(self):
        self.document.refresh()
        return self

    def add_dependency(self, ndi_document, key=None):
        return self.document.add_dependency(ndi_document, key=key)

    def __eq__(self, ndi_object) -> bool:
        return self.document.serialize() == ndi_object.document.serialize()

    def add_data_property(self, key, value):
        self.document.data[key] = value

    def delete(self, force=False, remove_history=False):
        self.document.delete(force=force, remove_history=remove_history)
    

    def __getattribute__(self, key):
        """Allows user to access properties in ndi_object.document.data off of the ndi_object instance."""
        try:
            return object.__getattribute__(self, 'document').data[key]
        except (KeyError, AttributeError):
            return object.__getattribute__(self, key)

    def __setattr__(self, key, value):
        """Allows user to set properties in ndi_object.document.data from the ndi_object."""
        try:
            object.__getattribute__(self, 'document').data[key]
            # This looks weird, so...
            # If line above does not throw an error, then we set the value.
            # Line below does not work alone because instead of a key error,
            #   it will just create the key and set the value to it.
            object.__getattribute__(self, 'document').data[key] = value
        except (KeyError, AttributeError):
            propobj = getattr(self.__class__, key, None)
            if isinstance(propobj, property):
                if propobj.fset:
                    propobj.fset(self, value)
            else:
                super().__setattr__(key, value)

        

class DaqSystem(NDI_Object):
    """
    A flatbuffer interface for DAQ systems.

    .. currentmodule:: ndi.ndi_object

    Inherits from the :class:`NDI_Object` abstract class.
    """

    DOCUMENT_TYPE = 'ndi_daq_system'

    def __init__(
        self,
        name: str,
        file_navigator: T.FileNavigator,
        daq_reader: T.DaqReader,
        epoch_probe_map,
        experiment_id: T.NdiId = None,
        epoch_ids: T.List[T.NdiId] = [],
        id_: T.NdiId = None
    ) -> None:
        """DaqSystem constructor: initializes with fields defined in `ndi_schema <https://>`_'s DaqSystem table. For use when creating a new DaqSystem instance from scratch.
        ::
            new_daq_system = DaqSystem(**fields)

        .. currentmodule:: ndi.file_navigator

        :param name: [description]
        :type name: str
        :param file_navigator: [description]
        :type file_navigator: :class:`FileNavigator`
        :param daq_reader: Name of DaqReader class used to read files from FileNavigator.
        :type daq_reader: str
        :param experiment_id: defaults to None
        :type experiment_id: str, optional
        :param id_: defaults to None
        :type id_: str, optional
        """
        super().__init__(id_)
        self.metadata['name'] = name
        self.metadata['type'] = self.DOCUMENT_TYPE
        self.metadata['experiment_id'] = experiment_id
        self.add_data_property('epoch_ids', epoch_ids)

        self.epoch_probe_map = epoch_probe_map
        if epoch_probe_map:
            self.add_data_property('epoch_probe_map_class', epoch_probe_map.__name__)
        self.daq_reader = daq_reader
        if daq_reader:
            self.add_data_property('daq_reader_class', daq_reader.__name__)
        if file_navigator:
            file_navigator.daq_system_id = self.id
            self.file_navigator = file_navigator
            # file_navigator is added to db in Experiment._add_daq_system()

    @classmethod
    def from_document(cls, document) -> DaqSystem:
        """Alternate DaqSystem constructor. For use whan initializing from a document.
        ::
            reconstructed_daq_system = DaqSystem.from_document(fb)

        :type document: ndi.Document

        .. currentmodule:: ndi.daq_system

        :rtype: :class:`DaqSystem`
        """

        ds = cls(
            id_=document.id,
            name=document.metadata['name'],
            experiment_id=document.metadata['experiment_id'],
            epoch_ids=document.data['epoch_ids'],
            file_navigator=None,
            epoch_probe_map=None,
            daq_reader=lambda id: None,
        )
        ds.document = document
        return ds

    def provision(self, experiment: T.Experiment):
        experiment.connect(daq_systems=[self])

        epoch_sets = self.file_navigator.get_epoch_set(experiment.directory)
        epochprobemap = self.epoch_probe_map(
            daq_reader=self.daq_reader,
            epoch_sets=epoch_sets,
            experiment_id=self.metadata['experiment_id'],
            ctx=self.ctx,
        )

        epochs, probes, channels = epochprobemap.get_epochs_probes_channels()

        # set relationships, verify types, and add to database.
        for e in epochs:
            e.daq_system_ids.append(self.id)
            self.epoch_ids.append(e.id)
            experiment.upsert(e, force=True)
        self.ctx.db.update(self.document, force=True)
        for p in probes:
            p.daq_system_id = self.id
            experiment.upsert(p, force=True)
        for c in channels:
            c.daq_system_id = self.id
            experiment.upsert(c, force=True)

        return epochs, probes, channels
    
    def link_epoch(self, epoch):
        """For linking an epoch and daq system that are both already in the same database.

        :param epoch: [description]
        :type epoch: [type]
        """
        e.daq_system_ids.append(self.id)
        self.epoch_ids.append(e.id)
        self.ctx.db.update(epoch.document, force=True)
        self.ctx.db.update(self.document, force=True)

    def get_epochs(self):
        is_ndi_epoch_type = Q('_metadata.type') == Epoch.DOCUMENT_TYPE
        is_related = Q('daq_system_ids').contains(self.id)
        query = is_ndi_epoch_type & is_related
        return [
            Epoch.from_document(doc).with_ctx(self.ctx)
            for doc in self.ctx.db.find(query)
        ]

    def get_probes(self):
        is_ndi_epoch_type = Q('_metadata.type') == Probe.DOCUMENT_TYPE
        is_related = Q('daq_system_id') == self.id
        query = is_ndi_epoch_type & is_related
        return [
            Probe.from_document(doc).with_ctx(self.ctx)
            for doc in self.ctx.db.find(query)
        ]

    def get_channels(self):
        is_ndi_epoch_type = Q('_metadata.type') == Channel.DOCUMENT_TYPE
        is_related = Q('daq_system_id') == self.id
        query = is_ndi_epoch_type & is_related
        return [
            Channel.from_document(doc).with_ctx(self.ctx)
            for doc in self.ctx.db.find(query)
        ]

    def get_file_navigator(self):
        is_ndi_epoch_type = Q('_metadata.type') == Channel.DOCUMENT_TYPE
        is_related = Q('daq_system_id') == self.id
        query = is_ndi_epoch_type & is_related
        results = [
            FileNavigator.from_document(doc).with_ctx(self.ctx)
            for doc in self.ctx.db.find(query)
        ]
        return results[0] if results else None



class EpochSet:
    """ TODO
    """

    def __init__(self, root, epochfiles, metadatafile):
        self.root = root
        self.epochfiles = epochfiles
        self.metadatafile = metadatafile


class FileNavigator(NDI_Object):
    """
    A flatbuffer interface for file_navigators.

    .. currentmodule:: ndi.ndi_object

    Inherits from the :class:`NDI_Object` abstract class.
    """

    DOCUMENT_TYPE = 'ndi_file_navigator'

    def __init__(
        self,
        epoch_file_patterns: T.List[T.RegexStr],
        metadata_file_pattern: T.RegexStr,
        id_: T.NdiId = None
    ) -> None:
        """FileNavigator constructor: initializes with fields defined in `ndi_schema <https://>`_'s FileNavigator table. For use when creating a new FileNavigator instance from scratch.
        ::
            new_file_navigator = FileNavigator(**fields)

        :param epoch_file_patterns: A regex string identifying file names with epoch data.
        :type epoch_file_patterns: str
        :param metadata_file_pattern: A regex string identifying file names containing metadata.
        :type metadata_file_pattern: str
        """
        super().__init__(id_)
        self.metadata['type'] = self.DOCUMENT_TYPE
        self.add_data_property('epoch_file_patterns', epoch_file_patterns)
        self.add_data_property('metadata_file_pattern', metadata_file_pattern)

    @classmethod
    def from_document(cls, document) -> FileNavigator:
        fn = cls(
            id_=document.id,
            epoch_file_patterns=document.data['epoch_file_patterns'],
            metadata_file_pattern=document.data['metadata_file_pattern']
        )
        fn.document = document
        return fn

    def update(
        self,
        epoch_file_patterns=None,
        metadata_file_pattern=None,
    ) -> None:
        if epoch_file_patterns:
            self.epoch_file_patterns = epoch_file_patterns
        if metadata_file_pattern:
            self.metadata_file_pattern = metadata_file_pattern
        self.ctx.db.update(self.document, force=True)


    def get_epoch_set(self, directory: T.FilePath):
        """Given a directory, extracts, separates, and stores all files containing epoch or metadata. Files are identified using instance's epoch_file_patterns and metadata_file_pattern.

        :param directory: A path to the data directory.
        :type directory: str
        """
        file_parameters = re.compile('|'.join(self.epoch_file_patterns))
        self.epochs = []
        for root, _, files in os.walk(directory):
            epochfiles = [
                os.path.abspath(os.path.join(root, file))
                for file in files
                if file_parameters.match(file)
            ]
            if epochfiles:
                metadatafile = next(
                    file for file in epochfiles
                    if re.match(self.metadata_file_pattern, file)
                )
                self.epochs.append(EpochSet(root, epochfiles, metadatafile))
                self.epochs.sort(key=lambda epoch: epoch.root)
        return self.epochs



class Experiment(NDI_Object):
    """
    A flatbuffer interface for experiments.

    .. currentmodule:: ndi.ndi_object

    Inherits from the :class:`NDI_Object` abstract class.
    """

    DOCUMENT_TYPE = 'ndi_experiment'

    def __init__(self, name: str, id_: T.NdiId = None):
        """Experiment constructor: initializes with fields defined in `ndi_schema <https://>`_'s Experiment table. For use when creating a new Experiment instance from scratch.
        ::
            new_experiment = Experiment(**fields)

        .. currentmodule:: ndi.daq_system

        :param name: [description]
        :type name: str
        :param id_: = defaults to None
        :type id_: str, optional
        """
        super().__init__(id_)
        self.metadata['name'] = name
        self.metadata['type'] = self.DOCUMENT_TYPE
        self.metadata['experiment_id'] = self.id

        self.daq_systems: T.List[DaqSystem] = []
        self.daq_readers_map: T.Dict[str, T.DaqReader] = {}
    
    def __overwrite_with_document(self, document):
        self.document = document

    def connect(
        self,
        directory='',
        database=None,
        binary_collection=None,
        daq_systems=[],
        load_existing=False
    ):
        """This will connect the experiment to the database and binary collection. 
        If this experiment already exists in the database (identified by _metadata.name),
        then this experiment is loaded with its contents in database.
        Otherwise, this experiment is added to the database a new experiment.

        :param database: [description], defaults to None
        :type database: [type], optional
        :param binary_collection: [description], defaults to None
        :type binary_collection: [type], optional
        :param load_existing: [description], defaults to False
        :type load_existing: bool, optional
        :raises RuntimeError: [description]
        :raises Warning: [description]
        :return: [description]
        :rtype: [type]
        """
        if directory:
            if not Path(directory).is_dir():
                raise RuntimeError(f'Experiment\'s raw data directory ({directory}) is not a directory. Please check that the path is correct or create a new experiment directory and try again.')
            self.ctx.raw_data_directory = directory
        if database: 
            if not isinstance(database, NDI_Database):
                raise RuntimeError(f'{database} is not an ndi.database.NDI_Database.')
            self.ctx.database = database
            isExperiment = Q('_metadata.type') == self.DOCUMENT_TYPE
            ownName = self.metadata['name']
            hasOwnName = Q('_metadata.name') == ownName
            preexisting_experiment = database.find(isExperiment & hasOwnName)
            if preexisting_experiment:
                if not load_existing:
                    raise RuntimeError(f'An experiment with the name {ownName} already exists in this database. To connect to it, set load_existing to True. To make a new experiment, please choose a unique name.')
                self.__overwrite_with_document(preexisting_experiment[0])
            else:
                if load_existing:
                    raise Warning(f'An experiment with the name {ownName} does not yet exist in this database. To add this experiment to the database, set load_existing to False.')
                self.ctx.db.add(self.document)
        if binary_collection:
            self.ctx.binary_collection = binary_collection
        if daq_systems:
            for daq_sys in daq_systems:
                self.ctx.load_daq_system(daq_sys)
                self._add_daq_system(daq_sys)
        return self

    @property
    def directory(self):
        return self.ctx.raw_data_directory

    # Document Methods
    @classmethod
    def from_database(cls, db, ndi_query: T.Query):
        is_experiment = Q('_metadata') == Experiment.DOCUMENT_TYPE
        ndi_query = is_experiment & ndi_query
        documents = db.find(ndi_query=ndi_query)
        return [
            cls.from_document(d) 
            for d in documents 
            if d.metadata['type'] == cls.DOCUMENT_TYPE
        ]
        
    @classmethod
    def from_document(cls, document) -> Experiment:
        """Alternate Experiment constructor. For use whan initializing from a document bytearray.
        ::
            reconstructed_experiment = Experiment.from_document(fb)

        :type document: ndi.Document

        .. currentmodule:: ndi.experiment

        :rtype: :class:`Experiment`
        """
        print(f'Warning: Experiment.connect() has not been run on this experiment ({document.id}). It will be minimally functional until connected.')
        exp = cls(
            id_=document.id,
            name=document.metadata['name'],
        )
        exp.document = document
        return exp

    # Experiment Methods
    def update(self, name: str) -> None:
        if name:
            self.name = name
        self.ctx.db.update(self.document, force=True)

    def _add_daq_system(self, daq_system: T.DaqSystem) -> None:
        """Stores a daq_system instance and labels it with the experiment's id.
            DOES NOT ADD DAQ SYSTEM TO CONTEXT

        .. currentmodule:: ndi.daq_system

        :type daq_system: :class:`DaqSystem`
        """
        if isinstance(daq_system, str): 
            # if daq_system is an id
            # this will occur when an experiment is being rebuilt from a document
            daq_system = self.ctx.db.find_by_id(daq_system)
            if not daq_system:
                raise ValueError(f'A DAQ system with id {daq_system} does not exist in the database.')
            daq_system.metadata['experiment_id'] = self.id
        else:
            daq_system.metadata['experiment_id'] = self.id
            if self.ctx:
                self.ctx.db.upsert(daq_system.document, force=True)
                self.ctx.db.upsert(daq_system.file_navigator.document, force=True)
                daq_system.set_ctx(self.ctx)
                daq_system.file_navigator.set_ctx = self.ctx

    def _connect_ndi_object(self, ndi_object):
        ndi_object.metadata['experiment_id'] = self.id
        ndi_object.set_ctx(self.ctx)

    def upsert(self, ndi_object: T.NdiObjectWithExperimentId, force=False) -> None:
        self._connect_ndi_object(ndi_object)
        self.ctx.db.upsert(ndi_object.document, force=force)

    def add_related_obj_to_db(self, ndi_object: T.NdiObjectWithExperimentId) -> None:
        self._connect_ndi_object(ndi_object)
        self.ctx.db.add(ndi_object.document)

    def add_epoch(self, epoch: T.Epoch):
        if not isinstance(epoch, Epoch):
            raise TypeError(f'Object {epoch} is not an instance of ndi.Epoch.')
        self.__check_foreign_key_requirements(epoch, ['daq_system_ids'])
        epoch.set_ctx(self.ctx)
        self.add_related_obj_to_db(epoch)

    def add_probe(self, probe: T.Probe):
        if not isinstance(probe, Probe):
            raise TypeError(f'Object {probe} is not an instance of ndi.Probe.')
        self.__check_foreign_key_requirements(probe, ['daq_system_id'])
        probe.set_ctx(self.ctx)
        self.add_related_obj_to_db(probe)

    def add_channel(self, channel: T.Channel):
        if not isinstance(channel, Channel):
            raise TypeError(f'Object {channel} is not an instance of ndi.Channel.')
        self.__check_foreign_key_requirements(channel, ['epoch_id', 'probe_id', 'daq_system_id'])
        channel.set_ctx(self.ctx)
        self.add_related_obj_to_db(channel)

    def __check_foreign_key_requirements(self, ndi_object, foreign_keys):
        for key in foreign_keys:
            if key.endswith('_ids'):
                related_ids = getattr(ndi_object, key)
                for id_ in related_ids:
                    self.__verify_relation_exists_in_experiment(ndi_object, id_)
            else:
                related_id = getattr(ndi_object, key)
                if not related_id:
                    raise RuntimeError(f'Object {ndi_object} is missing its required {key}.')
                self.__verify_relation_exists_in_experiment(ndi_object, related_id)

    def __verify_relation_exists_in_experiment(self, ndi_object, related_id):
        relation = self.ctx.db.find_by_id(related_id)
        relation_experiment_id = relation.metadata['experiment_id']
        relation_type = relation.metadata['type']
        if not relation:
            raise RuntimeError(f'Object {ndi_object} appears to have a foreign key to {relation_type}:{related_id}, which does not yet exist. Please add {relation_type}:{related_id} to the experiment before trying again.')
        elif relation_experiment_id != self.metadata['experiment_id']:
            raise RuntimeError(f'Object {ndi_object} appears to have a foreign key to {relation_type}:{related_id}, which belongs to another experiment({relation_experiment_id}).')

    def get_daq_systems(self):
        is_ndi_epoch_type = Q('_metadata.type') == DaqSystem.DOCUMENT_TYPE
        is_related = Q('experiment_id') == self.id
        query = is_ndi_epoch_type & is_related
        return [
            DaqSystem.from_document(doc).with_ctx(self.ctx)
            for doc in self.ctx.db.find(query)
        ]
    
    def set_readers(self, channels):
        for c in channels:
            if c.daq_reader_class_name in self.ctx.daq_readers_map:
                c.set_reader(self.ctx.daq_readers_map[c.daq_reader_class_name])
            else:
                if c.daq_reader_class_name:
                    whats_missing = f'DAQ reader {c.daq_reader_class_name} not'
                    how_to_fix = ' If necessary, connect this experiment to the appropriate DAQ system.'
                else:
                    whats_missing = 'No DAQ reader'
                    how_to_fix = ''
                print(f'{whats_missing} set to {c}.{how_to_fix}')
        return channels

    def get_epochs(self):
        return self.get_ndi_object_dependencies(Epoch)
    def get_probes(self):
        return self.get_ndi_object_dependencies(Probe)
    def get_channels(self):
        channels = self.get_ndi_object_dependencies(Channel)
        return self.set_readers(channels)

    def get_ndi_object_dependencies(self, NdiClass):
        has_this_experiment_id = Q('_metadata.experiment_id') == self.id
        is_desired_class = Q('_metadata.type') == NdiClass.DOCUMENT_TYPE
        documents = self.ctx.db.find(has_this_experiment_id & is_desired_class)
        ndi_objects = [
            NdiClass.from_document(d).with_ctx(self.ctx) 
            for d in documents
        ]
        return ndi_objects

    def get_document_dependencies(self):
        return {
            key: doc.with_ctx(self.ctx)
            for key, doc in self.document.get_dependencies().items()
        }

    def find_epochs(self, ndi_query):
        return self._find_by_class(Epoch, ndi_query)
    def find_probes(self, ndi_query):
        return self._find_by_class(Probe, ndi_query)
    def find_channels(self, ndi_query):
        channels = self._find_by_class(Channel, ndi_query)
        return self.set_readers(channels)

    def _find_by_class(self, NdiClass, ndi_query):
        has_this_experiment_id = Q('_metadata.experiment_id') == self.id
        class_filter = Q('_metadata.type') == NdiClass.DOCUMENT_TYPE
        docs = self.ctx.db.find(has_this_experiment_id & class_filter & ndi_query)
        return [NdiClass.from_document(d).with_ctx(self.ctx) for d in docs]

    def check_id_in_database(self, id_):
        return bool(self.ctx.db.find_by_id(id_))

    def check_dependency_exists(self, id_):
        for item in self.dependencies.values():
            if isinstance(item, Document):
                if item.id == id_:
                    return True
            elif item == id_:
                return True
        return False

    def add_document(self, doc, key=None):
        doc.metadata['experiment_id'] = self.id
        doc.set_ctx(self.ctx)
        self.add_dependency(doc, key=key)



class Epoch(NDI_Object):
    """
    A flatbuffer interface for epochs.

    .. currentmodule:: ndi.ndi_object

    Inherits from the :class:`NDI_Object` abstract class.
    """
    # TODO: require daq_system_id after implementing DaqReaders

    DOCUMENT_TYPE = 'ndi_epoch'

    def __init__(
        self, 
        daq_system_ids: T.List[T.NdiId] = [], 
        experiment_id: T.NdiId = None,
        reference_dir: str = '',
        id_: T.NdiId = None
    ) -> None:
        """Epoch constructor: initializes with fields defined in `ndi_schema <https://>`_'s Epoch table. For use when creating a new Epoch instance from scratch.
        ::
            new_epoch = Epoch(**fields)

        :param daq_system_id: defaults to ''
        :type daq_system_id: str, optional
        :param id_: defaults to None
        :type id_: str, optional
        """
        super().__init__(id_)
        self.metadata['type'] = self.DOCUMENT_TYPE
        self.metadata['experiment_id'] = experiment_id
        self.add_data_property('reference_dir', reference_dir)
        self.add_data_property('daq_system_ids', daq_system_ids)

    @classmethod
    def from_document(cls, document) -> Epoch:
        """Alternate Epoch constructor. For use whan initializing from a document.
        ::
            reconstructed_epoch = Epoch.from_document(fb)

        :type document: ndi.Document

        .. currentmodule:: ndi.epoch

        :rtype: :class:`Epoch`
        """
        epoch = cls(
            id_=document.id,
            experiment_id=document.metadata['experiment_id'],
            daq_system_ids=document.data['daq_system_ids'],
        )
        epoch.document = document
        return epoch

    def add_daq_system(self, daq_system):
        if not self.ctx.db.find_by_id(daq_system.id):
            raise RuntimeError('DaqSystem does not exist in database and cannot be connected.')

        daq_system.epoch_ids.append(e.id)
        self.daq_system_ids.append(self.id)
        
        self.ctx.db.update(daq_system.document, force=True)
        self.update()


    def update(self, experiment_id: T.NdiId = None) -> None:
        if experiment_id: self.experiment_id = experiment_id
        self.ctx.db.update(self.document, force=True)

    def get_experiment(self):
        doc = self.ctx.db.find_by_id(self.experiment_id)
        return doc and Experiment.from_document(doc).with_ctx(self.ctx)

    def get_daq_systems(self):
        is_ndi_epoch_type = Q('_metadata.type') == DaqSystem.DOCUMENT_TYPE
        is_related = Q('epoch_ids').contains(self.id)
        query = is_ndi_epoch_type & is_related
        return [
            DaqSystem.from_document(doc).with_ctx(self.ctx)
            for doc in self.ctx.db.find(query)
        ]

    def get_channels(self):
        is_ndi_channel_type = Q('_metadata.type') == Channel.DOCUMENT_TYPE
        is_related = Q('epoch_id') == self.id
        query = is_ndi_channel_type & is_related
        channels = self.ctx.db.find(query)
        return [
            Channel.from_document(c).with_ctx(self.ctx)
            for c in channels
        ]



class Probe(NDI_Object):
    """
    A flatbuffer interface for probes.

    .. currentmodule:: ndi.ndi_object

    Inherits from the :class:`NDI_Object` abstract class.
    """

    DOCUMENT_TYPE = 'ndi_probe'

    def __init__(
        self,
        name: str,
        reference: int,
        type_: str,
        id_: T.NdiId = None,
        daq_system_id: T.NdiId = None,
        experiment_id: T.NdiId = None,
    ) -> None:
        """Probe constructor: initializes with fields defined in `ndi_schema <https://>`_'s Probe table. For use when creating a new Probe instance from scratch.
        ::
            new_probe = Probe(**fields)

        :param name:
        :type name: str
        :param reference:
        :type reference: int
        :param type_:
        :type type_: str
        :param id_: defaults to None
        :type id_: str, optional
        :param daq_system_id: defaults to ''
        :type daq_system_id: str, optional
        :raises TypeError: When *type_* is not from the list of :mod:`ndi.probe_type`.
        """
        super().__init__(id_)
        self.metadata['name'] = name
        self.metadata['type'] = self.DOCUMENT_TYPE
        self.metadata['experiment_id'] = experiment_id
        self.add_data_property('reference', reference)
        self.add_data_property('daq_system_id', daq_system_id)
        self.add_data_property('type', type_)

    # Document Methods
    @classmethod
    def from_document(cls, document) -> Probe:
        """Alternate Probe constructor. For use whan initializing from a document.
        ::
            reconstructed_probe = Probe.from_document(fb)

        :type document: ndi.Document

        .. currentmodule:: ndi.probe

        :rtype: :class:`Probe`
        """
        probe = cls(
            id_=document.id,
            name=document.metadata['name'],
            reference=document.data['reference'],
            type_=document.data['type'],
            daq_system_id=document.data['daq_system_id'],
            experiment_id=document.metadata['experiment_id'],
        )
        probe.document = document
        return probe

    def update(
        self,
        name: str,
        reference: int,
        type_: str,
        daq_system_id: T.NdiId = None,
        experiment_id: T.NdiId = None,
    ) -> None:
        if name:
            self.name = name
        if reference:
            self.reference = reference
        if type_:
            self.type_ = type_
        if daq_system_id:
            self.daq_system_id = daq_system_id
        if experiment_id:
            self.experiment_id = experiment_id
        self.ctx.db.update(self.document, force=True)

    def add_channel(self, channel):
        if channel.metadata['type'] != Channel.DOCUMENT_TYPE:
            raise TypeError(f'Object {channel} is not an instance of ndi.Channel.')
        
        channel.metadata['experiment_id'] = self.metadata['experiment_id']
        channel.probe_id = self.id
        channel.daq_system_id = self.daq_system_id

        channel.set_ctx(self.ctx)
        self.ctx.db.add(channel.document)

    def get_channels(self):
        is_ndi_channel_type = Q('_metadata.type') == Channel.DOCUMENT_TYPE
        is_related = Q('probe_id') == self.id
        query = is_ndi_channel_type & is_related
        return [
            Channel.from_document(doc).with_ctx(self.ctx)
            for doc in self.ctx.db.find(query)
        ]

    def get_daq_system(self):
        return [
            DaqSystem.from_document(doc).with_ctx(self.ctx)
            for doc in self.ctx.db.find_by_id(self.daq_system_id)
        ]

    def get_experiment(self):
        doc = self.ctx.db.find_by_id(self.experiment_id)
        return Experiment.from_document(doc).with_ctx(self.ctx)



class Channel(NDI_Object):
    """A flatbuffer interface for channels.

    .. currentmodule:: ndi.ndi_object

    Inherits from the :class:`NDI_Object` abstract class.
    """

    DOCUMENT_TYPE = 'ndi_channel'

    def __init__(
        self,
        name: str,
        number: int,
        type_: str,
        source_file: str,
        daq_reader_class_name: str = None,
        daq_reader = None,
        probe_id: T.NdiId = None,
        epoch_id: T.NdiId = None,
        daq_system_id: T.NdiId = None,
        experiment_id: T.NdiId = None,
        id_: T.NdiId = None,
        clock_type: str = 'no_time'
    ) -> None:
        """Channel constructor: initializes with fields defined in `ndi_schema <https://>`_'s Channel table. For use when creating a new Channel instance from scratch.
        ::
            new_channel = Channel(**fields)

        :param name: Abbreviated type with number (e.g. ai21, do3, aux13).
        :type name: str
        :param number: [description]
        :type number: int
        :param type_: One of the types defined in :mod:`ndi.channel_type`.
        :type type_: str
        :param source_file: [description]
        :type source_file: str
        :param epoch_id: [description]
        :type epoch_id: str
        :param probe_id: [description]
        :type probe_id: str
        :param daq_system_id: defaults to '<empty_string>'
        :type daq_system_id: str, optional
        :type id_: str, optional
        :param clock_type: defaults to 'no_time'
        :type clock_type: str, optional

        .. currentmodule:: ndi.channel

        :rtype: :class:`Channel`
        """
        super().__init__(id_)
        self.metadata['name'] = name
        self.metadata['type'] = self.DOCUMENT_TYPE
        self.metadata['experiment_id'] = experiment_id
        self.add_data_property('number', number)
        self.add_data_property('type', type_)
        self.add_data_property('clock_type', clock_type)
        self.add_data_property('source_file', source_file)
        self.add_data_property('daq_reader_class_name', daq_reader_class_name)
        self.add_data_property('probe_id', probe_id)
        self.add_data_property('epoch_id', epoch_id)
        self.add_data_property('daq_system_id', daq_system_id)
        self.daq_reader = daq_reader(source_file) if daq_reader else None

    @classmethod
    def from_document(cls, document) -> Channel:
        """Alternate Channel constructor. For use whan initializing from a document.
        ::
            reconstructed_channel = Channel.from_document(fb)

        :type document: ndi.Document

        .. currentmodule:: ndi.channel

        :rtype: :class:`Channel`
        """
        channel = cls(
            id_=document.id,
            name=document.metadata['name'],
            number=document.data['number'],
            type_=document.data['type'],
            clock_type=document.data['clock_type'],
            source_file=document.data['source_file'],
            daq_reader_class_name=document.data['daq_reader_class_name'],
            probe_id=document.data['probe_id'],
            epoch_id=document.data['epoch_id'],
            daq_system_id=document.data['daq_system_id'],
            experiment_id=document.metadata['experiment_id'],
        )
        channel.document = document
        return channel

    def update(
        self,
        name: str,
        number: int,
        type_: str,
        source_file: str,
        daq_reader_class_name: T.NdiId,
        probe_id: T.NdiId,
        epoch_id: T.NdiId,
        daq_system_id: T.NdiId = None,
        experiment_id: T.NdiId = None,
        clock_type: str = 'no_time'
    ) -> None:
        if name: self.name = name
        if number: self.number = number
        if type_: self.type = type_
        if source_file: self.source_file = source_file
        if daq_reader_class_name: self.daq_reader_class_name = daq_reader_class_name
        if probe_id: self.probe_id = probe_id
        if epoch_id: self.epoch_id = epoch_id
        if daq_system_id: self.daq_system_id = daq_system_id
        if experiment_id: self.experiment_id = experiment_id
        if clock_type: self.clock_type = clock_type

        self.ctx.db.update(self.document, force=True)

    def set_reader(self, daq_reader, force=False):
        if daq_reader.__name__ == self.daq_reader_class_name:
            self.daq_reader = daq_reader
        elif force:
            self.daq_reader = daq_reader
            self.daq_reader_class_name = daq_reader.__name__
        else:
            raise Warning(f'DAQ reader {daq_reader.__name__} does not match the one previously set on ndi.Channel {self}. To override {self.daq_reader_class_name} with {daq_reader.__name__}, set the force argument to True.')

    def read(self, **kwargs):
        if self.type == 'event':
            return self.daq_reader.readevents(self.number, **kwargs)
        else:
            return self.daq_reader.readchannel(self.number, **kwargs)

    def samplerate(self):
        return self.daq_reader.samplerate(self.number)

    def get_epoch(self):
        doc = self.ctx.db.find_by_id(self.epoch_id)
        return Epoch.from_document(doc).with_ctx(self.ctx)

    def get_probe(self):
        doc = self.ctx.db.find_by_id(self.probe_id)
        return Probe.from_document(doc).with_ctx(self.ctx)

    def get_daq_system(self):
        doc = self.ctx.db.find_by_id(self.daq_system_id)
        return DaqSystem.from_document(doc).with_ctx(self.ctx)

    def get_experiment(self):
        doc = self.ctx.db.find_by_id(self.experiment_id)
        return Experiment.from_document(doc).with_ctx(self.ctx)
