from __future__ import annotations
import ndi.types as T
from abc import ABC, abstractmethod
import flatbuffers
from uuid import uuid4
import os
import re
import ndi.daqreaders as DaqReaders
from .document import Document

class NDI_Object:
    """
    Abstract class for NDI flatbuffer interfaces.
    Child classes of :class:`NDI_Object` are wrappers for the classes generated by `ndi_schema <>`_ and serve as simplified interfaces for quickly converting between ndi objects and flatbuffer bytearrays.
    """

    DOCUMENT_TYPE = ''

    def __init__(self,  id_: T.Optional[T.NdiId]):
        """NDI_Object constructor: initializes id property.
        op8
        :param id_: A unique id.
        :type id_: str, optional
        """
        self.document = Document(id_=id_)
    
    @property
    def ctx(self):
        return self.document.ctx
    @ctx.setter
    def ctx(self, new_ctx):
        self.document.ctx = new_ctx
    
    @property
    def binary(self):
        return self.document.binary
    @property
    def binary_collection(self):
        return self.document.binary_collection
    @binary_collection.setter
    def binary_collection(self, new_binary_collection):
        self.document.set_binary_collection(new_binary_collection)

    @property
    def id(self):
        return self.document.id

    @property
    def metadata(self):
        return self.document.metadata
    @metadata.setter
    def metadata(self, new_metadata):
        self.document.metadata = new_metadata

    @property
    def dependencies(self):
        return self.document.dependencies
    @dependencies.setter
    def dependencies(self, dependencies):
        self.document.dependencies = dependencies

    @property
    def depends_on(self):
        return self.document.depends_on
    @depends_on.setter
    def depends_on(self, depends_on):
        self.document.depends_on = depends_on
    
    @property
    def current(self):
        return self.refresh()

    def refresh(self):
        self.document.refresh()
        return self

    def add_dependency(self, ndi_document, key=None):
        return self.document.add_dependency(ndi_document, key=key)

    def __eq__(self, ndi_object) -> bool:
        return self.document.serialize() == ndi_object.document.serialize()

    def add_data_property(self, key, value):
        self.document.data[key] = value

    def __getattribute__(self, key):
        """Allows user to access properties in ndi_object.document.data off of the ndi_object instance."""
        try:
            return object.__getattribute__(self, 'document').data[key]
        except (KeyError, AttributeError):
            return object.__getattribute__(self, key)

    def __setattr__(self, key, value):
        """Allows user to set properties in ndi_object.document.data from the ndi_object."""
        try:
            object.__getattribute__(self, 'document').data[key]
            # This looks weird, so...
            # If line above does not throw an error, then we set the value.
            # Line below does not work alone because instead of a key error,
            #   it will just create the key and set the value to it.
            object.__getattribute__(self, 'document').data[key] = value
        except (KeyError, AttributeError):
            propobj = getattr(self.__class__, key, None)
            if isinstance(propobj, property):
                if propobj.fset:
                    propobj.fset(self, value)
            else:
                super().__setattr__(key, value)


class Experiment(NDI_Object):
    """
    A flatbuffer interface for experiments.

    .. currentmodule:: ndi.ndi_object

    Inherits from the :class:`NDI_Object` abstract class.
    """

    DOCUMENT_TYPE = EXPERIMENT_DOCUMENT_TYPE

    def __init__(self, name: str, daq_system_ids: T.List[T.DaqSystem] = [], id_: T.NdiId = None):
        """Experiment constructor: initializes with fields defined in `ndi_schema <https://>`_'s Experiment table. For use when creating a new Experiment instance from scratch.
        ::
            new_experiment = Experiment(**fields)

        .. currentmodule:: ndi.daq_system

        :param name: [description]
        :type name: str
        :param daq_system_ids: a list of daq_system instances, defaults to []
        :type daq_system_ids: List[:class:`DaqSystem`], optional
        :param id_: = defaults to None
        :type id_: str, optional
        """
        super().__init__(id_)
        self.metadata['name'] = name
        self.metadata['type'] = self.DOCUMENT_TYPE
        self.metadata['experiment_id'] = self.id
        self.add_data_property('daq_system_ids', [])
        for daq_system in daq_system_ids:
            self.add_daq_system(daq_system)
    
    def __overwrite_with_document(self, document):
        self.document = document

    def connect(self, database=None, binary_collection=None, load_existing=False):
        """This will connect the experiment to the database and binary collection. 
        If this experiment already exists in the database (identified by _metadata.name),
        then this experiment is loaded with its contents in database.
        Otherwise, this experiment is added to the database a new experiment.

        :param database: [description], defaults to None
        :type database: [type], optional
        :param binary_collection: [description], defaults to None
        :type binary_collection: [type], optional
        :param load_existing: [description], defaults to False
        :type load_existing: bool, optional
        :raises RuntimeError: [description]
        :raises Warning: [description]
        :return: [description]
        :rtype: [type]
        """
        if database: 
            self.ctx = database
            isExperiment = Q('_metadata.type') == self.DOCUMENT_TYPE
            ownName = self.metadata['name']
            hasOwnName = Q('_metadata.name') == ownName
            preexisting_experiment = database.find(isExperiment & hasOwnName)
            if preexisting_experiment:
                if not load_existing:
                    raise RuntimeError(f'An experiment with the name {ownName} already exists in this database. To connect to it, set load_existing to True. To make a new experiment, please choose a unique name.')
                self.__overwrite_with_document(preexisting_experiment[0])
            else:
                if load_existing:
                    raise Warning(f'An experiment with the name {ownName} does not yet exist in this database. To add this experiment to the database, set load_existing to False.')
                self.ctx.add(self.document)
        if binary_collection:
            self.binary_collection = binary_collection
        return self

    # Document Methods
    @classmethod
    def from_database(cls, db, ndi_query: T.Query):
        documents = db.find(ndi_query=ndi_query)
        return [
            cls.from_document(d) 
            for d in documents 
            if d.metadata['type'] == cls.DOCUMENT_TYPE
        ]
        
    @classmethod
    def from_document(cls, document) -> Experiment:
        """Alternate Experiment constructor. For use whan initializing from a document bytearray.
        ::
            reconstructed_experiment = Experiment.from_document(fb)

        :type document: ndi.Document

        .. currentmodule:: ndi.experiment

        :rtype: :class:`Experiment`
        """
        return cls(
            id_=document.id,
            name=document.metadata['name'],
            daq_system_ids=document.data['daq_system_ids']
        )

    # Experiment Methods
    def update(self, name: str) -> None:
        if name:
            self.name = name
        self.ctx.update(self.document, force=True)

    def add_daq_system(self, daq_system: T.DaqSystem) -> None:
        """Stores a daq_system instance and labels it with the experiment's id.

        .. currentmodule:: ndi.daq_system

        :type daq_system: :class:`DaqSystem`
        """
        if isinstance(daq_system, str): 
            # if daq_system is an id
            # this will occur when an experiment is being rebuilt from a document
            daq_system = self.ctx.find_by_id(daq_system)
            if not daq_system:
                raise ValueError(f'A DAQ system with id {daq_system} does not exist in the database.')
            daq_system.metadata['experiment_id'] = self.id
            self.daq_system_ids.append(daq_system)
        else:
            daq_system.metadata['experiment_id'] = self.id
            self.daq_system_ids.append(daq_system.id)
            if self.ctx:
                self.ctx.add(daq_system.document)


    def add_related_obj_to_db(self, ndi_object: T.NdiObjectWithExperimentId) -> None:
        ndi_object.metadata['experiment_id'] = self.id
        ndi_object.ctx = self.ctx
        ndi_object.binary_collection = self.binary_collection
        self.ctx.add(ndi_object.document)

    def add_epoch(self, epoch: T.Epoch):
        if not isinstance(epoch, Epoch):
            raise TypeError(f'Object {epoch} is not an instance of ndi.Epoch.')
        self.__check_foreign_key_requirements(epoch, ['channel_ids', 'daq_system_id'])

        self.add_related_obj_to_db(epoch)

    def add_probe(self, probe: T.Probe):
        if not isinstance(probe, Probe):
            raise TypeError(f'Object {probe} is not an instance of ndi.Probe.')
        self.__check_foreign_key_requirements(probe, ['daq_system_id'])
        
        self.add_related_obj_to_db(probe)

    def add_channel(self, channel: T.Channel):
        if not isinstance(channel, Channel):
            raise TypeError(f'Object {channel} is not an instance of ndi.Channel.')
        self.__check_foreign_key_requirements(channel, ['epoch_ids', 'probe_id', 'daq_system_id'])
        
        self.add_related_obj_to_db(channel)

    def __check_foreign_key_requirements(self, ndi_object, foreign_keys):
        for key in foreign_keys:
            if key.endswith('_ids'):
                related_ids = getattr(ndi_object, key)
                for id_ in related_ids:
                    self.__verify_relation_exists_in_experiment(ndi_object, id_)
            else:
                related_id = getattr(ndi_object, key)
                if not related_id:
                    raise RuntimeError(f'Object {ndi_object} is missing its required {key}.')
                self.__verify_relation_exists_in_experiment(ndi_object, related_id)

    def __verify_relation_exists_in_experiment(self, ndi_object, related_id):
        relation = self.ctx.find_by_id(related_id)
        relation_experiment_id = relation.metadata['experiment_id']
        relation_type = relation.metadata['type']
        if not relation:
            raise RuntimeError(f'Object {ndi_object} appears to have a foreign key to {relation_type}:{related_id}, which does not yet exist. Please add {relation_type}:{related_id} to the experiment before trying again.')
        elif relation_experiment_id != self.metadata['experiment_id']:
            raise RuntimeError(f'Object {ndi_object} appears to have a foreign key to {relation_type}:{related_id}, which belongs to another experiment({relation_experiment_id}).')

    def get_epochs(self):
        return self.get_ndi_dependencies(Epoch)
    def get_probes(self):
        return self.get_ndi_dependencies(Probe)
    def get_channels(self):
        return self.get_ndi_dependencies(Channel)

    def get_ndi_dependencies(self, NdiClass):
        has_this_experiment_id = Q('_metadata.experiment_id') == self.id
        is_desired_class = Q('_metadata.type') == NdiClass.DOCUMENT_TYPE
        documents = self.ctx.find(has_this_experiment_id & is_desired_class)
        ndi_objects = [NdiClass.from_document(d) for d in documents]
        return ndi_objects

    def find_epochs(self, ndi_query):
        return self._find_by_class(Epoch, ndi_query)
    def find_probes(self, ndi_query):
        return self._find_by_class(Probe, ndi_query)
    def find_channels(self, ndi_query):
        return self._find_by_class(Channel, ndi_query)

    def _find_by_class(self, NdiClass, ndi_query):
        class_filter = Q('_metadata.type') == NdiClass.DOCUMENT_TYPE
        docs = self.ctx.find(class_filter & ndi_query)
        return [NdiClass.from_document(d) for d in docs]

    def check_id_in_database(self, id_):
        return bool(self.ctx.find_by_id(id_))

    def check_dependency_exists(self, id_):
        for item in self.dependencies.values():
            if isinstance(item, Document):
                if item.id == id_:
                    return True
            elif item == id_:
                return True
        return False

    def add_document(self, doc, key=None):
        doc.metadata['experiment_id'] = self.id
        doc.set_ctx(self.ctx)
        doc.set_binary_collection(self.binary_collection)
        self.add_dependency(doc, key=key)

    def get_documents(self):
        ndi_object_prefixes = [f'{o.DOCUMENT_TYPE}:' for o in [Epoch, Probe, Channel]]
        # filter out ndi_objects
        documents = {}



class DaqSystem(NDI_Object):
    """
    A flatbuffer interface for DAQ systems.

    .. currentmodule:: ndi.ndi_object

    Inherits from the :class:`NDI_Object` abstract class.
    """

    DOCUMENT_TYPE = DAQ_SYSTEM_DOCUMENT_TYPE

    def __init__(
        self,
        name: str,
        file_navigator: T.FileNavigator,
        daq_reader: T.DaqReader,
        experiment_id: T.NdiId = None,
        id_: T.NdiId = None
    ) -> None:
        """DaqSystem constructor: initializes with fields defined in `ndi_schema <https://>`_'s DaqSystem table. For use when creating a new DaqSystem instance from scratch.
        ::
            new_daq_system = DaqSystem(**fields)

        .. currentmodule:: ndi.file_navigator

        :param name: [description]
        :type name: str
        :param file_navigator: [description]
        :type file_navigator: :class:`FileNavigator`
        :param daq_reader: Name of DaqReader class used to read files from FileNavigator.
        :type daq_reader: str
        :param experiment_id: defaults to None
        :type experiment_id: str, optional
        :param id_: defaults to None
        :type id_: str, optional
        """
        super().__init__(id_)
        self.metadata['name'] = name
        self.metadata['type'] = self.DOCUMENT_TYPE
        self.metadata['experiment_id'] = experiment_id

        # TODO: figure out how to handle these as documents (pending daq sys)
        self.file_navigator = file_navigator
        self.add_daq_reader(daq_reader)
        

    @classmethod
    def from_document(cls, document) -> DaqSystem:
        """Alternate DaqSystem constructor. For use whan initializing from a document.
        ::
            reconstructed_daq_system = DaqSystem.from_document(fb)

        :type document: ndi.Document

        .. currentmodule:: ndi.daq_system

        :rtype: :class:`DaqSystem`
        """

        return cls(
            id_=document.id,
            name=document.metadata['name'],
            experiment_id=document.metadata['experiment_id'],
            file_navigator=None,
            daq_reader=lambda id: None,
        )

    def add_daq_reader(self, daq_reader: T.DaqReader) -> None:
        self.daq_reader = daq_reader(self.id)

    def provision(self, experiment: T.Experiment) -> None:
        if self not in experiment.daq_systems:
            experiment.add_daq_system(self)

        # NOTE: This is where the channels, probes, and epochs would all be added 
        # to the database as a part of the given experiment.

        # NOTE: I think this is also where the daq system will add itself to the database 
        #   (if it's not already in it)



class EpochFiles:
    """ TODO
    """

    def __init__(self, epochfiles, metadatafile):
        self.epochfiles = epochfiles
        self.metadatafile = metadatafile


class FileNavigator(NDI_Object):
    """
    A flatbuffer interface for file_navigators.

    .. currentmodule:: ndi.ndi_object

    Inherits from the :class:`NDI_Object` abstract class.
    """

    def __init__(
        self,
        epoch_file_patterns: T.List[T.RegexStr],
        metadata_file_pattern: T.RegexStr
    ) -> None:
        """FileNavigator constructor: initializes with fields defined in `ndi_schema <https://>`_'s FileNavigator table. For use when creating a new FileNavigator instance from scratch.
        ::
            new_file_navigator = FileNavigator(**fields)

        :param epoch_file_patterns: A regex string identifying file names with epoch data.
        :type epoch_file_patterns: str
        :param metadata_file_pattern: A regex string identifying file names containing metadata.
        :type metadata_file_pattern: str
        """
        self.epoch_file_patterns = epoch_file_patterns
        self.metadata_file_pattern = metadata_file_pattern

    @classmethod
    def from_flatbuffer(cls, flatbuffer: bytes) -> FileNavigator:
        """Alternate FileNavigator constructor. For use whan initializing from a flatbuffer bytearray.
        ::
            reconstructed_file_navigator = FileNavigator.from_flatbuffer(fb)

        :param flatbuffer:
        :type flatbuffer: bytearray

        .. currentmodule:: ndi.file_navigator

        :rtype: :class:`FileNavigator`
        """
        file_navigator = build_file_navigator.FileNavigator.GetRootAsFileNavigator(
            flatbuffer, 0)
        return cls._reconstruct(file_navigator)

    @classmethod
    def _reconstruct(cls, file_navigator: T.FileNavigator_schema) -> FileNavigator:
        """Alternate FileNavigator constructor. For use whan initializing from a flatbuffer generated class instance.

        :param file_navigator: FileNavigator object created from class generated by `ndi_schema<https://>`_
        :type file_navigator: ndi.schema.FileNavigator.FileNavigator

        .. currentmodule:: ndi.file_navigator

        :rtype: :class:`FileNavigator`
        """
        epoch_file_patterns = [
            file_navigator.EpochFilePatterns(i).decode('utf8')
            for i in range(file_navigator.EpochFilePatternsLength())
        ]

        return cls(
            epoch_file_patterns=epoch_file_patterns,
            metadata_file_pattern=file_navigator.MetadataFilePattern().decode('utf8')
        )

    def _build(self, builder: T.Builder) -> T.BuildOffset:
        """.. currentmodule:: ndi.ndi_object

        Called in NDI_Object.serialize() as part of flatbuffer bytearray generation from FileNavigator instance.

        :param builder: Builder class in flatbuffers module.
        :type builder: flatbuffers.Builder
        """
        epoch_file_patterns = self._buildStringVector(
            builder, self.epoch_file_patterns)
        metadata_file_pattern = builder.CreateString(
            self.metadata_file_pattern)

        build_file_navigator.FileNavigatorStart(builder)
        build_file_navigator.FileNavigatorAddEpochFilePatterns(
            builder, epoch_file_patterns)
        build_file_navigator.FileNavigatorAddMetadataFilePattern(
            builder, metadata_file_pattern)
        return build_file_navigator.FileNavigatorEnd(builder)

    def get_epochs(self, directory: T.FilePath) -> None:
        """Given a directory, extracts, separates, and stores all files containing epoch or metadata. Files are identified using instance's epoch_file_patterns and metadata_file_pattern.

        :param directory: A path to the data directory.
        :type directory: str
        """
        file_parameters = re.compile('|'.join(self.epoch_file_patterns))
        self.epochs = []
        for root, _, files in os.walk(directory):
            epochfiles = [
                os.path.abspath(os.path.join(root, file))
                for file in files
                if file_parameters.match(file)
            ]
            if epochfiles:
                # TODO: fix? metadata file pattern might not also match epoch file pattern.
                metadatafile = [
                    file for file in epochfiles
                    if re.match(self.metadata_file_pattern, file)
                ][0]
                self.epochs.append(EpochFiles(epochfiles, metadatafile))
