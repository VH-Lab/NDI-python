from __future__ import annotations
import ndi.types as T
from .document import Document
from did import Query as Q
from pathlib import Path
from uuid import uuid4
import os
import re

class NDI_Object:
    """
    Abstract class for NDI flatbuffer interfaces.
    Child classes of :class:`NDI_Object` are wrappers for the classes generated by `ndi_schema <>`_ and serve as simplified interfaces for quickly converting between ndi objects and flatbuffer bytearrays.
    """

    DOCUMENT_TYPE = ''

    def __init__(self,  id_: T.Optional[T.NdiId]):
        """NDI_Object constructor: initializes id property.
        op8
        :param id_: A unique id.
        :type id_: str, optional
        """
        self.document = Document(id_=id_)
    
    @property
    def ctx(self):
        return self.document.ctx

    def set_ctx(self, new_ctx):
        self.document.set_ctx(new_ctx)
    def with_ctx(self, new_ctx):
        self.document.set_ctx(new_ctx)
        return self
    
    @property
    def binary(self):
        return self.document.binary

    @property
    def id(self):
        return self.document.id

    @property
    def base(self):
        return self.document.base
    @base.setter
    def base(self, new_base):
        self.document.base = new_base

    @property
    def class_(self):
        return self.document.class_
    @class_.setter
    def class_(self, new_class):
        self.document.class_ = new_class

    @property
    def dependencies(self):
        return self.document.dependencies
    @dependencies.setter
    def dependencies(self, dependencies):
        self.document.dependencies = dependencies

    @property
    def depends_on(self):
        return self.document.depends_on
    @depends_on.setter
    def depends_on(self, depends_on):
        self.document.depends_on = depends_on
    
    @property
    def current(self):
        return self.refresh()

    def refresh(self):
        self.document.refresh()
        return self

    def add_dependency(self, ndi_document, name=None, save=None):
        return self.document.add_dependency(ndi_document, name=name, save=save)

    def make_dependent_on(self, ndi_document, name=None, save=None):
        return self.document.make_dependent_on(ndi_document, name=name, save=save)

    def __eq__(self, ndi_object) -> bool:
        return self.document.serialize() == ndi_object.document.serialize()

    def add_data_property(self, key, value):
        self.document.data[key] = value

    def delete(self, remove_history=False):
        self.document.delete(remove_history=remove_history)

        

class DaqSystem(NDI_Object):
    """
    A flatbuffer interface for DAQ systems.

    .. currentmodule:: ndi.ndi_object

    Inherits from the :class:`NDI_Object` abstract class.
    """

    DOCUMENT_TYPE = 'ndi_daq_system'

    def __init__(
        self,
        name: str,
        file_navigator: T.FileNavigator,
        daq_reader: T.DaqReader,
        epoch_probe_map,
        session_id: T.NdiId = None,
        epoch_ids: T.List[T.NdiId] = [],
        id_: T.NdiId = None
    ) -> None:
        """DaqSystem constructor: initializes with fields defined in `ndi_schema <https://>`_'s DaqSystem table. For use when creating a new DaqSystem instance from scratch.
        ::
            new_daq_system = DaqSystem(**fields)

        .. currentmodule:: ndi.file_navigator

        :param name: [description]
        :type name: str
        :param file_navigator: [description]
        :type file_navigator: :class:`FileNavigator`
        :param daq_reader: Name of DaqReader class used to read files from FileNavigator.
        :type daq_reader: str
        :param session_id: defaults to None
        :type session_id: str, optional
        :param id_: defaults to None
        :type id_: str, optional
        """
        super().__init__(id_)
        self.base['name'] = name
        self.class_['name'] = self.DOCUMENT_TYPE
        self.base['session_id'] = session_id
        self.add_data_property('epoch_ids', epoch_ids)

        self.epoch_probe_map = epoch_probe_map
        if epoch_probe_map:
            self.add_data_property('epoch_probe_map_class', epoch_probe_map.__name__)
        self.daq_reader = daq_reader
        if daq_reader:
            self.add_data_property('daq_reader_class', daq_reader.__name__)
        if file_navigator:
            file_navigator.daq_system_id = self.id
            self.file_navigator = file_navigator
            # file_navigator is added to db in Session._add_daq_system()

    @classmethod
    def from_document(cls, document) -> DaqSystem:
        """Alternate DaqSystem constructor. For use when initializing from a document.
        ::
            reconstructed_daq_system = DaqSystem.from_document(fb)

        :type document: ndi.Document

        .. currentmodule:: ndi.daq_system

        :rtype: :class:`DaqSystem`
        """

        ds = cls(
            id_=document.id,
            name=document.base['name'],
            session_id=document.base['session_id'],
            epoch_ids=document.data['epoch_ids'],
            file_navigator=None,
            epoch_probe_map=None,
            daq_reader=lambda id: None,
        )
        ds.document = document
        return ds

    def provision(self, session: T.Session):
        session.connect(daq_systems=[self])

        epoch_sets = self.file_navigator.get_epoch_set(session.directory)
        epochprobemap = self.epoch_probe_map(
            daq_reader=self.daq_reader,
            epoch_sets=epoch_sets,
            session_id=self.base['session_id'],
            ctx=self.ctx,
        )

        epochs, probes, channels = epochprobemap.get_epochs_probes_channels()

        # set relationships, verify types, and add to database.
        for epoch in epochs:
            epoch.daq_system_ids.append(self.id)
            self.epoch_ids.append(epoch.id)
            session.upsert(epoch)
        self.ctx.did.update(self.document)
        for probe in probes:
            probe.daq_system_id = self.id
            session.upsert(probe)
        for channel in channels:
            channel.daq_system_id = self.id
            session.upsert(channel)

        return epochs, probes, channels
    
    def link_epoch(self, epoch):
        """For linking an epoch and daq system that are both already in the same database.

        :param epoch: [description]
        :type epoch: [type]
        """
        e.daq_system_ids.append(self.id)
        self.epoch_ids.append(epoch.id)
        self.ctx.did.update(epoch.document)
        self.ctx.did.update(self.document)

    def get_epochs(self):
        is_ndi_epoch_type = Q('document_class.name') == Epoch.DOCUMENT_TYPE
        is_related = Q('daq_system_ids').contains(self.id)
        query = is_ndi_epoch_type & is_related
        return [
            Epoch.from_document(doc).with_ctx(self.ctx)
            for doc in self.ctx.did.find(query)
        ]

    def get_probes(self):
        is_ndi_epoch_type = Q('document_class.name') == Probe.DOCUMENT_TYPE
        is_related = Q('daq_system_id') == self.id
        query = is_ndi_epoch_type & is_related
        return [
            Probe.from_document(doc).with_ctx(self.ctx)
            for doc in self.ctx.did.find(query)
        ]

    def get_channels(self):
        is_ndi_epoch_type = Q('document_class.name') == Channel.DOCUMENT_TYPE
        is_related = Q('daq_system_id') == self.id
        query = is_ndi_epoch_type & is_related
        return [
            Channel.from_document(doc).with_ctx(self.ctx)
            for doc in self.ctx.did.find(query)
        ]

    def get_file_navigator(self):
        is_ndi_epoch_type = Q('document_class.name') == Channel.DOCUMENT_TYPE
        is_related = Q('daq_system_id') == self.id
        query = is_ndi_epoch_type & is_related
        results = [
            FileNavigator.from_document(doc).with_ctx(self.ctx)
            for doc in self.ctx.did.find(query)
        ]
        return results[0] if results else None



class EpochSet:
    """ TODO
    """

    def __init__(self, root, epochfiles, metadatafile):
        self.root = root
        self.epochfiles = epochfiles
        self.metadatafile = metadatafile


class FileNavigator(NDI_Object):
    """
    A flatbuffer interface for file_navigators.

    .. currentmodule:: ndi.ndi_object

    Inherits from the :class:`NDI_Object` abstract class.
    """

    DOCUMENT_TYPE = 'ndi_file_navigator'

    def __init__(
        self,
        epoch_file_patterns: T.List[T.RegexStr],
        metadata_file_pattern: T.RegexStr,
        id_: T.NdiId = None
    ) -> None:
        """FileNavigator constructor: initializes with fields defined in `ndi_schema <https://>`_'s FileNavigator table. For use when creating a new FileNavigator instance from scratch.
        ::
            new_file_navigator = FileNavigator(**fields)

        :param epoch_file_patterns: A regex string identifying file names with epoch data.
        :type epoch_file_patterns: str
        :param metadata_file_pattern: A regex string identifying file names containing metadata.
        :type metadata_file_pattern: str
        """
        super().__init__(id_)
        self.class_['name'] = self.DOCUMENT_TYPE
        self.add_data_property('epoch_file_patterns', epoch_file_patterns)
        self.add_data_property('metadata_file_pattern', metadata_file_pattern)

    @classmethod
    def from_document(cls, document) -> FileNavigator:
        fn = cls(
            id_=document.id,
            epoch_file_patterns=document.data['epoch_file_patterns'],
            metadata_file_pattern=document.data['metadata_file_pattern']
        )
        fn.document = document
        return fn

    def update(
        self,
        epoch_file_patterns=None,
        metadata_file_pattern=None,
    ) -> None:
        if epoch_file_patterns:
            self.epoch_file_patterns = epoch_file_patterns
        if metadata_file_pattern:
            self.metadata_file_pattern = metadata_file_pattern
        self.ctx.did.update(self.document)


    def get_epoch_set(self, directory: T.FilePath):
        """Given a directory, extracts, separates, and stores all files containing epoch or metadata. Files are identified using instance's epoch_file_patterns and metadata_file_pattern.

        :param directory: A path to the data directory.
        :type directory: str
        """
        file_parameters = re.compile('|'.join(self.epoch_file_patterns))
        self.epochs = []
        for root, _, files in os.walk(directory):
            epochfiles = [
                os.path.abspath(os.path.join(root, file))
                for file in files
                if file_parameters.match(file)
            ]
            if epochfiles:
                metadatafile = next(
                    file for file in epochfiles
                    if re.match(self.metadata_file_pattern, file)
                )
                self.epochs.append(EpochSet(root, epochfiles, metadatafile))
                self.epochs.sort(key=lambda epoch: epoch.root)
        return self.epochs



class Session(NDI_Object):
    """
    A flatbuffer interface for sessions.

    .. currentmodule:: ndi.ndi_object

    Inherits from the :class:`NDI_Object` abstract class.
    """

    DOCUMENT_TYPE = 'ndi_session'

    def __init__(self, name: str, id_: T.NdiId = None):
        """Session constructor: initializes with fields defined in `ndi_schema <https://>`_'s Session table. For use when creating a new Session instance from scratch.
        ::
            new_session = Session(**fields)

        .. currentmodule:: ndi.daq_system

        :param name: [description]
        :type name: str
        :param id_: = defaults to None
        :type id_: str, optional
        """
        super().__init__(id_)
        self.base['name'] = name
        self.base['session_id'] = self.id
        self.class_['name'] = self.DOCUMENT_TYPE

        self.daq_systems: T.List[DaqSystem] = []
        self.daq_readers_map: T.Dict[str, T.DaqReader] = {}
    
    def __overwrite_with_document(self, document):
        self.document = document
    
    def save(self):
        self.document.save()

    def connect(
        self,
        data_interface_database=None,
        daq_systems=[],
        load_existing=False
    ):
        """This will connect the session to the database and binary collection. 
        If this session already exists in the database (identified by _metadata.name),
        then this session is loaded with its contents in database.
        Otherwise, this session is added to the database a new session.

        :param data_interface_database: [description], defaults to None
        :type data_interface_database: [type], optional
        :param binary_collection: [description], defaults to None
        :type binary_collection: [type], optional
        :param load_existing: [description], defaults to False
        :type load_existing: bool, optional
        :raises RuntimeError: [description]
        :raises Warning: [description]
        :return: [description]
        :rtype: [type]
        """
        if not data_interface_database and not self.ctx.did:
            raise RuntimeError(f'Sessions must {data_interface_database} have an associated DID instance.')
        else: 
            self.ctx.data_interface_database = data_interface_database
        isSession = Q('document_class.name') == self.DOCUMENT_TYPE
        ownName = self.base['name']
        hasOwnName = Q('base.name') == ownName
        preexisting_session = data_interface_database.find(isSession & hasOwnName)
        if preexisting_session:
            if not load_existing:
                raise RuntimeError(f'An session with the name {ownName} already exists in this database. To connect to it, set load_existing to True. To make a new session, please choose a unique name.')
            self.__overwrite_with_document(preexisting_session[0])
        else:
            if load_existing:
                raise Warning(f'An session with the name {ownName} does not yet exist in this database. To add this session to the database, set load_existing to False.')
            else:
                self.ctx.did.add(self.document, save=False)
        if daq_systems:
            for daq_sys in daq_systems:
                self.ctx.load_daq_system(daq_sys)
                self._add_daq_system(daq_sys)
        self.ctx.did.save()

        return self

    @property
    def directory(self):
        return self.ctx.raw_data_directory

    # Document Methods
    @classmethod
    def from_database(cls, db, ndi_query):
        is_session = Q('document_class.name') == Session.DOCUMENT_TYPE
        ndi_query = is_session & ndi_query
        documents = db.find(ndi_query=ndi_query)
        return [
            cls.from_document(d) 
            for d in documents 
            if d.metadata['type'] == cls.DOCUMENT_TYPE
        ]
        
    @classmethod
    def from_document(cls, document) -> Session:
        """Alternate Session constructor. For use when initializing from a document bytearray.
        ::
            reconstructed_session = Session.from_document(fb)

        :type document: ndi.Document

        .. currentmodule:: ndi.session

        :rtype: :class:`Session`
        """
        print(f'Warning: Session.connect() has not been run on this session ({document.id}). It will be minimally functional until connected.')
        exp = cls(
            id_=document.id,
            name=document.base['name'],
        )
        exp.document = document
        return exp

    # Session Methods
    def update(self, name: str) -> None:
        if name:
            self.name = name
        self.ctx.did.update(self.document)

    def _add_daq_system(self, daq_system: T.DaqSystem) -> None:
        """Stores a daq_system instance and labels it with the session's id.
            DOES NOT ADD DAQ SYSTEM TO CONTEXT

        .. currentmodule:: ndi.daq_system

        :type daq_system: :class:`DaqSystem`
        """
        if isinstance(daq_system, str): 
            # if daq_system is an id
            # this will occur when an session is being rebuilt from a document
            daq_system = self.ctx.did.find_by_id(daq_system)
            if not daq_system:
                raise ValueError(f'A DAQ system with id {daq_system} does not exist in the database.')
            daq_system.base['session_id'] = self.id
        else:
            daq_system.base['session_id'] = self.id
            if self.ctx:
                self.ctx.did.upsert(daq_system.document)
                self.ctx.did.upsert(daq_system.file_navigator.document)
                daq_system.set_ctx(self.ctx)
                daq_system.file_navigator.set_ctx = self.ctx

    def _connect_ndi_object(self, ndi_object):
        ndi_object.base['session_id'] = self.id
        ndi_object.set_ctx(self.ctx)

    def upsert(self, ndi_object: T.NdiObjectWithSessionId) -> None:
        self._connect_ndi_object(ndi_object)
        self.ctx.did.upsert(ndi_object.document)

    def add_related_obj_to_db(self, ndi_object: T.NdiObjectWithSessionId) -> None:
        self._connect_ndi_object(ndi_object)
        self.ctx.did.add(ndi_object.document)

    def add_epoch(self, epoch: T.Epoch):
        if not isinstance(epoch, Epoch):
            raise TypeError(f'Object {epoch} is not an instance of ndi.Epoch.')
        self.__check_foreign_key_requirements(epoch, ['daq_system_ids'])
        epoch.set_ctx(self.ctx)
        self.add_related_obj_to_db(epoch)

    def add_probe(self, probe: T.Probe):
        if not isinstance(probe, Probe):
            raise TypeError(f'Object {probe} is not an instance of ndi.Probe.')
        self.__check_foreign_key_requirements(probe, ['daq_system_id'])
        probe.set_ctx(self.ctx)
        self.add_related_obj_to_db(probe)

    def add_channel(self, channel: T.Channel):
        if not isinstance(channel, Channel):
            raise TypeError(f'Object {channel} is not an instance of ndi.Channel.')
        self.__check_foreign_key_requirements(channel, ['epoch_id', 'probe_id', 'daq_system_id'])
        channel.set_ctx(self.ctx)
        self.add_related_obj_to_db(channel)

    def __check_foreign_key_requirements(self, ndi_object, foreign_keys):
        for key in foreign_keys:
            if key.endswith('_ids'):
                related_ids = getattr(ndi_object, key)
                for id_ in related_ids:
                    self.__verify_relation_exists_in_session(ndi_object, id_)
            else:
                related_id = getattr(ndi_object, key)
                if not related_id:
                    raise RuntimeError(f'Object {ndi_object} is missing its required {key}.')
                self.__verify_relation_exists_in_session(ndi_object, related_id)

    def __verify_relation_exists_in_session(self, ndi_object, related_id):
        relation = self.ctx.did.find_by_id(related_id)
        relation_session_id = relation.base['session_id']
        relation_type = relation.metadata['type']
        if not relation:
            raise RuntimeError(f'Object {ndi_object} appears to have a foreign key to {relation_type}:{related_id}, which does not yet exist. Please add {relation_type}:{related_id} to the session before trying again.')
        elif relation_session_id != self.base['session_id']:
            raise RuntimeError(f'Object {ndi_object} appears to have a foreign key to {relation_type}:{related_id}, which belongs to another session({relation_session_id}).')

    def get_daq_systems(self):
        is_ndi_epoch_type = Q('document_class.name') == DaqSystem.DOCUMENT_TYPE
        is_related = Q('session_id') == self.id
        query = is_ndi_epoch_type & is_related
        return [
            DaqSystem.from_document(doc).with_ctx(self.ctx)
            for doc in self.ctx.did.find(query)
        ]
    
    def set_readers(self, channels):
        for c in channels:
            if c.daq_reader_class_name in self.ctx.daq_readers_map:
                c.set_reader(self.ctx.daq_readers_map[c.daq_reader_class_name])
            else:
                if c.daq_reader_class_name:
                    whats_missing = f'DAQ reader {c.daq_reader_class_name} not'
                    how_to_fix = ' If necessary, connect this session to the appropriate DAQ system.'
                else:
                    whats_missing = 'No DAQ reader'
                    how_to_fix = ''
                print(f'{whats_missing} set to {c}.{how_to_fix}')
        return channels

    def get_epochs(self):
        return self.get_ndi_object_dependencies(Epoch)
    def get_probes(self):
        return self.get_ndi_object_dependencies(Probe)
    def get_channels(self):
        channels = self.get_ndi_object_dependencies(Channel)
        return self.set_readers(channels)

    def get_ndi_object_dependencies(self, NdiClass):
        has_this_session_id = Q('base.session_id') == self.id
        is_desired_class = Q('document_class.name') == NdiClass.DOCUMENT_TYPE
        documents = self.ctx.did.find(has_this_session_id & is_desired_class)
        ndi_objects = [
            NdiClass.from_document(d).with_ctx(self.ctx) 
            for d in documents
        ]
        return ndi_objects

    def get_document_dependencies(self):
        return {
            name: doc.with_ctx(self.ctx) if doc else None
            for name, doc in self.document.get_dependencies().items()
        }

    def find_epochs(self, ndi_query):
        return self._find_by_class(Epoch, ndi_query)
    def find_probes(self, ndi_query):
        return self._find_by_class(Probe, ndi_query)
    def find_channels(self, ndi_query):
        channels = self._find_by_class(Channel, ndi_query)
        return self.set_readers(channels)
    def find_documents(self, ndi_query):
        filter_ = Q('base.session_id') == self.id
        return self.ctx.did.find(filter_ & ndi_query)

    def _find_by_class(self, NdiClass, ndi_query):
        filter_ = ((Q('base.session_id') == self.id) \
            | (Q('base.session_id') == self.id)) \
            & (Q('document_class.name') == NdiClass.DOCUMENT_TYPE)
        docs = self.ctx.did.find(filter_ & ndi_query)
        return [NdiClass.from_document(d).with_ctx(self.ctx) for d in docs]

    def check_id_in_database(self, id_):
        return bool(self.ctx.did.find_by_id(id_))

    def check_dependency_exists(self, id_):
        for item in self.dependencies.values():
            if isinstance(item, Document):
                if item.id == id_:
                    return True
            elif item == id_:
                return True
        return False

    def add_document(self, doc, name=None, save=None):
        doc.data['base']['session_id'] = self.id
        doc.set_ctx(self.ctx)
        self.add_dependency(doc, name=name, save=save)



class Epoch(NDI_Object):
    """
    A flatbuffer interface for epochs.

    .. currentmodule:: ndi.ndi_object

    Inherits from the :class:`NDI_Object` abstract class.
    """
    # TODO: require daq_system_id after implementing DaqReaders

    DOCUMENT_TYPE = 'ndi_epoch'

    def __init__(
        self, 
        daq_system_ids: T.List[T.NdiId] = [], 
        session_id: T.NdiId = None,
        reference_dir: str = '',
        id_: T.NdiId = None
    ) -> None:
        """Epoch constructor: initializes with fields defined in `ndi_schema <https://>`_'s Epoch table. For use when creating a new Epoch instance from scratch.
        ::
            new_epoch = Epoch(**fields)

        :param daq_system_id: defaults to ''
        :type daq_system_id: str, optional
        :param id_: defaults to None
        :type id_: str, optional
        """
        super().__init__(id_)
        self.class_['name'] = self.DOCUMENT_TYPE
        self.base['session_id'] = session_id
        self.add_data_property('reference_dir', reference_dir)
        self.add_data_property('daq_system_ids', daq_system_ids)

    @classmethod
    def from_document(cls, document) -> Epoch:
        """Alternate Epoch constructor. For use when initializing from a document.
        ::
            reconstructed_epoch = Epoch.from_document(fb)

        :type document: ndi.Document

        .. currentmodule:: ndi.epoch

        :rtype: :class:`Epoch`
        """
        epoch = cls(
            id_=document.id,
            session_id=document.base['session_id'],
            daq_system_ids=document.data['daq_system_ids'],
        )
        epoch.document = document
        return epoch

    def add_daq_system(self, daq_system):
        if not self.ctx.did.find_by_id(daq_system.id):
            raise RuntimeError('DaqSystem does not exist in database and cannot be connected.')

        daq_system.epoch_ids.append(e.id)
        self.daq_system_ids.append(self.id)
        
        self.ctx.did.update(daq_system.document)
        self.update()


    def update(self, session_id: T.NdiId = None) -> None:
        if session_id: self.session_id = session_id
        self.ctx.did.update(self.document)

    def get_session(self):
        doc = self.ctx.did.find_by_id(self.session_id)
        return doc and Session.from_document(doc).with_ctx(self.ctx)

    def get_daq_systems(self):
        is_ndi_epoch_type = Q('document_class.name') == DaqSystem.DOCUMENT_TYPE
        is_related = Q('epoch_ids').contains(self.id)
        query = is_ndi_epoch_type & is_related
        return [
            DaqSystem.from_document(doc).with_ctx(self.ctx)
            for doc in self.ctx.did.find(query)
        ]

    def get_channels(self):
        is_ndi_channel_type = Q('document_class.name') == Channel.DOCUMENT_TYPE
        is_related = Q('epoch_id') == self.id
        query = is_ndi_channel_type & is_related
        channels = self.ctx.did.find(query)
        return [
            Channel.from_document(c).with_ctx(self.ctx)
            for c in channels
        ]



class Probe(NDI_Object):
    """
    A flatbuffer interface for probes.

    .. currentmodule:: ndi.ndi_object

    Inherits from the :class:`NDI_Object` abstract class.
    """

    DOCUMENT_TYPE = 'ndi_probe'

    def __init__(
        self,
        name: str,
        reference: int,
        type_: str,
        id_: T.NdiId = None,
        daq_system_id: T.NdiId = None,
        session_id: T.NdiId = None,
    ) -> None:
        """Probe constructor: initializes with fields defined in `ndi_schema <https://>`_'s Probe table. For use when creating a new Probe instance from scratch.
        ::
            new_probe = Probe(**fields)

        :param name:
        :type name: str
        :param reference:
        :type reference: int
        :param type_:
        :type type_: str
        :param id_: defaults to None
        :type id_: str, optional
        :param daq_system_id: defaults to ''
        :type daq_system_id: str, optional
        :raises TypeError: When *type_* is not from the list of :mod:`ndi.probe_type`.
        """
        super().__init__(id_)
        self.base['name'] = name
        self.class_['name'] = self.DOCUMENT_TYPE
        self.base['session_id'] = session_id
        self.add_data_property('reference', reference)
        self.add_data_property('daq_system_id', daq_system_id)
        self.add_data_property('type', type_)

    # Document Methods
    @classmethod
    def from_document(cls, document) -> Probe:
        """Alternate Probe constructor. For use when initializing from a document.
        ::
            reconstructed_probe = Probe.from_document(fb)

        :type document: ndi.Document

        .. currentmodule:: ndi.probe

        :rtype: :class:`Probe`
        """
        probe = cls(
            id_=document.id,
            name=document.base['name'],
            reference=document.data['reference'],
            type_=document.data['type'],
            daq_system_id=document.data['daq_system_id'],
            session_id=document.base['session_id'],
        )
        probe.document = document
        return probe

    def update(
        self,
        name: str,
        reference: int,
        type_: str,
        daq_system_id: T.NdiId = None,
        session_id: T.NdiId = None,
    ) -> None:
        if name:
            self.name = name
        if reference:
            self.reference = reference
        if type_:
            self.type_ = type_
        if daq_system_id:
            self.daq_system_id = daq_system_id
        if session_id:
            self.session_id = session_id
        self.ctx.did.update(self.document)

    def add_channel(self, channel):
        if channel.metadata['type'] != Channel.DOCUMENT_TYPE:
            raise TypeError(f'Object {channel} is not an instance of ndi.Channel.')
        
        channel.base['session_id'] = self.base['session_id']
        channel.probe_id = self.id
        channel.daq_system_id = self.daq_system_id

        channel.set_ctx(self.ctx)
        self.ctx.did.add(channel.document)

    def get_channels(self):
        is_ndi_channel_type = Q('document_class.name') == Channel.DOCUMENT_TYPE
        is_related = Q('probe_id') == self.id
        query = is_ndi_channel_type & is_related
        return [
            Channel.from_document(doc).with_ctx(self.ctx)
            for doc in self.ctx.did.find(query)
        ]

    def get_daq_system(self):
        return [
            DaqSystem.from_document(doc).with_ctx(self.ctx)
            for doc in self.ctx.did.find_by_id(self.daq_system_id)
        ]

    def get_session(self):
        doc = self.ctx.did.find_by_id(self.session_id)
        return Session.from_document(doc).with_ctx(self.ctx)



class Channel(NDI_Object):
    """A flatbuffer interface for channels.

    .. currentmodule:: ndi.ndi_object

    Inherits from the :class:`NDI_Object` abstract class.
    """

    DOCUMENT_TYPE = 'ndi_channel'

    def __init__(
        self,
        name: str,
        number: int,
        type_: str,
        source_file: str,
        daq_reader_class_name: str = None,
        daq_reader = None,
        probe_id: T.NdiId = None,
        epoch_id: T.NdiId = None,
        daq_system_id: T.NdiId = None,
        session_id: T.NdiId = None,
        id_: T.NdiId = None,
        clock_type: str = 'no_time'
    ) -> None:
        """Channel constructor: initializes with fields defined in `ndi_schema <https://>`_'s Channel table. For use when creating a new Channel instance from scratch.
        ::
            new_channel = Channel(**fields)

        :param name: Abbreviated type with number (e.g. ai21, do3, aux13).
        :type name: str
        :param number: [description]
        :type number: int
        :param type_: One of the types defined in :mod:`ndi.channel_type`.
        :type type_: str
        :param source_file: [description]
        :type source_file: str
        :param epoch_id: [description]
        :type epoch_id: str
        :param probe_id: [description]
        :type probe_id: str
        :param daq_system_id: defaults to '<empty_string>'
        :type daq_system_id: str, optional
        :type id_: str, optional
        :param clock_type: defaults to 'no_time'
        :type clock_type: str, optional

        .. currentmodule:: ndi.channel

        :rtype: :class:`Channel`
        """
        super().__init__(id_)
        self.base['name'] = name
        self.class_['name'] = self.DOCUMENT_TYPE
        self.base['session_id'] = session_id
        self.add_data_property('number', number)
        self.add_data_property('type', type_)
        self.add_data_property('clock_type', clock_type)
        self.add_data_property('source_file', source_file)
        self.add_data_property('daq_reader_class_name', daq_reader_class_name)
        self.add_data_property('probe_id', probe_id)
        self.add_data_property('epoch_id', epoch_id)
        self.add_data_property('daq_system_id', daq_system_id)
        self.daq_reader = daq_reader(source_file) if daq_reader else None

    @classmethod
    def from_document(cls, document) -> Channel:
        """Alternate Channel constructor. For use when initializing from a document.
        ::
            reconstructed_channel = Channel.from_document(fb)

        :type document: ndi.Document

        .. currentmodule:: ndi.channel

        :rtype: :class:`Channel`
        """
        channel = cls(
            id_=document.id,
            name=document.base['name'],
            number=document.data['number'],
            type_=document.data['type'],
            clock_type=document.data['clock_type'],
            source_file=document.data['source_file'],
            daq_reader_class_name=document.data['daq_reader_class_name'],
            probe_id=document.data['probe_id'],
            epoch_id=document.data['epoch_id'],
            daq_system_id=document.data['daq_system_id'],
            session_id=document.base['session_id'],
        )
        channel.document = document
        return channel

    def update(
        self,
        name: str,
        number: int,
        type_: str,
        source_file: str,
        daq_reader_class_name: T.NdiId,
        probe_id: T.NdiId,
        epoch_id: T.NdiId,
        daq_system_id: T.NdiId = None,
        session_id: T.NdiId = None,
        clock_type: str = 'no_time'
    ) -> None:
        if name: self.name = name
        if number: self.number = number
        if type_: self.type = type_
        if source_file: self.source_file = source_file
        if daq_reader_class_name: self.daq_reader_class_name = daq_reader_class_name
        if probe_id: self.probe_id = probe_id
        if epoch_id: self.epoch_id = epoch_id
        if daq_system_id: self.daq_system_id = daq_system_id
        if session_id: self.session_id = session_id
        if clock_type: self.clock_type = clock_type

        self.ctx.did.update(self.document)

    def set_reader(self, daq_reader, force=False):
        if daq_reader.__name__ == self.daq_reader_class_name:
            self.daq_reader = daq_reader
        elif force:
            self.daq_reader = daq_reader
            self.daq_reader_class_name = daq_reader.__name__
        else:
            raise Warning(f'DAQ reader {daq_reader.__name__} does not match the one previously set on ndi.Channel {self}. To override {self.daq_reader_class_name} with {daq_reader.__name__}, set the force argument to True.')

    def read(self, **kwargs):
        if self.type == 'event':
            return self.daq_reader.readevents(self.number, **kwargs)
        else:
            return self.daq_reader.readchannel(self.number, **kwargs)

    def samplerate(self):
        return self.daq_reader.samplerate(self.number)

    def get_epoch(self):
        doc = self.ctx.did.find_by_id(self.epoch_id)
        return Epoch.from_document(doc).with_ctx(self.ctx)

    def get_probe(self):
        doc = self.ctx.did.find_by_id(self.probe_id)
        return Probe.from_document(doc).with_ctx(self.ctx)

    def get_daq_system(self):
        doc = self.ctx.did.find_by_id(self.daq_system_id)
        return DaqSystem.from_document(doc).with_ctx(self.ctx)

    def get_session(self):
        doc = self.ctx.did.find_by_id(self.session_id)
        return Session.from_document(doc).with_ctx(self.ctx)
