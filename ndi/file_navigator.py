from __future__ import annotations
from typing import TYPE_CHECKING
if TYPE_CHECKING:
    import ndi.type as T

import os
import re
from .ndi_object import NDI_Object
import ndi.schema.FileNavigator as build_file_navigator


class EpochFiles:
    """ TODO
    """
    def __init__(self, epochfiles, metadatafile):
        self.epochfiles = epochfiles
        self.metadatafile = metadatafile


class FileNavigator(NDI_Object):
    """
    A flatbuffer interface for file_navigators.

    .. currentmodule:: ndi.ndi_object

    Inherits from the :class:`NDI_Object` abstract class.
    """
    def __init__(
            self,
            epoch_file_patterns: T.List[T.RegexStr],
            metadata_file_pattern: T.RegexStr
        ) -> None:
        """FileNavigator constructor: initializes with fields defined in `ndi_schema <https://>`_'s FileNavigator table. For use when creating a new FileNavigator instance from scratch.
        ::
            new_file_navigator = FileNavigator(**fields)
        
        :param epoch_file_patterns: A regex string identifying file names with epoch data.
        :type epoch_file_patterns: str
        :param metadata_file_pattern: A regex string identifying file names containing metadata.
        :type metadata_file_pattern: str
        """
        self.epoch_file_patterns = epoch_file_patterns
        self.metadata_file_pattern = metadata_file_pattern

    @classmethod
    def from_flatbuffer(cls, flatbuffer: bytearray) -> FileNavigator:
        """Alternate FileNavigator constructor. For use whan initializing from a flatbuffer bytearray.
        ::
            reconstructed_file_navigator = FileNavigator.from_flatbuffer(fb)
        
        :param flatbuffer:
        :type flatbuffer: bytearray

        .. currentmodule:: ndi.file_navigator

        :rtype: :class:`FileNavigator`
        """
        file_navigator = build_file_navigator.FileNavigator.GetRootAsFileNavigator(
            flatbuffer, 0)
        return cls._reconstruct(file_navigator)

    @classmethod
    def _reconstruct(cls, file_navigator: T.FileNavigator_schema) -> FileNavigator:
        """Alternate FileNavigator constructor. For use whan initializing from a flatbuffer generated class instance.
        
        :param file_navigator: FileNavigator object created from class generated by `ndi_schema<https://>`_
        :type file_navigator: ndi.schema.FileNavigator.FileNavigator

        .. currentmodule:: ndi.file_navigator

        :rtype: :class:`FileNavigator`
        """
        epoch_file_patterns = [
            file_navigator.EpochFilePatterns(i).decode('utf8')
            for i in range(file_navigator.EpochFilePatternsLength())
        ]

        return cls(
            epoch_file_patterns=epoch_file_patterns,
            metadata_file_pattern=file_navigator.MetadataFilePattern().decode('utf8')
        )

    def _build(self, builder: T.Builder) -> T.BuildOffset:
        """.. currentmodule:: ndi.ndi_object
        
        Called in NDI_Object.serialize() as part of flatbuffer bytearray generation from FileNavigator instance.
        
        :param builder: Builder class in flatbuffers module.
        :type builder: flatbuffers.Builder
        """
        epoch_file_patterns = self._buildStringVector(
            builder, self.epoch_file_patterns)
        metadata_file_pattern = builder.CreateString(
            self.metadata_file_pattern)

        build_file_navigator.FileNavigatorStart(builder)
        build_file_navigator.FileNavigatorAddEpochFilePatterns(
            builder, epoch_file_patterns)
        build_file_navigator.FileNavigatorAddMetadataFilePattern(
            builder, metadata_file_pattern)
        return build_file_navigator.FileNavigatorEnd(builder)

    def get_epochs(self, directory: T.FilePath) -> None:
        """Given a directory, extracts, separates, and stores all files containing epoch or metadata. Files are identified using instance's epoch_file_patterns and metadata_file_pattern.
        
        :param directory: A path to the data directory.
        :type directory: str
        """
        file_parameters = re.compile('|'.join(self.epoch_file_patterns))
        self.epochs = []
        for root, _, files in os.walk(directory):
            epochfiles = [
                os.path.abspath(os.path.join(root, file))
                for file in files
                if file_parameters.match(file)
            ]
            if epochfiles:
                # TODO: fix? metadata file pattern might not also match epoch file pattern.
                metadatafile = [
                    file for file in epochfiles
                    if re.match(self.metadata_file_pattern, file)
                ][0]
                self.epochs.append(EpochFiles(epochfiles, metadatafile))
